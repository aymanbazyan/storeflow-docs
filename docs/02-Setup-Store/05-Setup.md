# Setup Guide

This guide details the steps required to set up and run the application using Docker. Docker handles all dependencies including PostgreSQL, Node.js, and the application itself.

## Setup Instructions

<!-- ### 1. Configure Environment Variables -->

<!-- Create a `.env` file in the project root with your database credentials: -->

<!-- ```ini
# .env
DATABASE_URL="postgresql://myuser:mypassword@db:5432/mydb?schema=public"
POSTGRES_USER=myuser
POSTGRES_PASSWORD=mypassword
POSTGRES_DB=mydb
..... See .env.example for the rest of
``` -->

<!-- **Important Notes:**
- Replace `myuser`, `mypassword`, and `mydb` with your desired credentials
- The host must be `db` (not `localhost`) - this is the Docker service name
- Keep these credentials secure and never commit the `.env` file to version control -->

### 1. Start the Application

#### Development Mode

```bash
# Start services
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up --build -d
```

```bash
# View logs
docker-compose logs -f
```

```bash
# Stop services
docker-compose -f docker-compose.yml -f docker-compose.dev.yml down
```

```bash
# Host Prisma studio
docker-compose exec app npm run prisma:studio
```

#### Production Mode

```bash
# Start services
docker-compose up --build -d
```

```bash
# View logs
docker-compose logs -f
```

```bash
# Stop services
docker-compose down
```

**Note:** The first startup will take longer as it builds the Next.js application and runs database migrations.

### 2. Initialize the Database Schema

The database schema is automatically initialized when you start the application. The Docker entrypoint script runs:

1. `prisma generate` - Generates the Prisma client
2. `prisma migrate deploy` - Applies all migrations
3. Builds and starts the application

### 3. Add Full-Text Search Functionality

The application's search feature relies on advanced PostgreSQL functions that **cannot be automatically generated by Prisma**. You must manually execute custom SQL.

**Execute the following commands:**

```bash
# Access the PostgreSQL container
docker-compose exec db psql -U myuser -d mydb
```

Replace `myuser` and `mydb` with the values from your `.env` file.

**Then run this SQL inside the psql terminal:**

```sql
-- STEP 1: DEFINE THE UPDATE FUNCTION
-- This function will be called by the trigger automatically.
-- We use 'setweight' to give matches in 'name' a higher priority ('A')
-- than matches in 'slug' ('B'). This can be used later to rank search results.
CREATE OR REPLACE FUNCTION update_product_search_vector()
RETURNS TRIGGER AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('simple', coalesce(NEW.name, '')), 'A') ||
    setweight(to_tsvector('simple', coalesce(NEW.slug, '')), 'B');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- STEP 2: CREATE THE TRIGGER
-- This trigger ensures the function runs automatically whenever a product is created or updated.
-- We drop the old one first to avoid errors.
DROP TRIGGER IF EXISTS tsvector_update ON "Product";
CREATE TRIGGER tsvector_update
  BEFORE INSERT OR UPDATE ON "Product"
  FOR EACH ROW
  EXECUTE FUNCTION update_product_search_vector();

-- STEP 3: BACKFILL EXISTING DATA (ONE-TIME)
-- This updates all existing products in your table to have a search_vector.
-- It's crucial for making old products searchable.
UPDATE "Product"
SET search_vector = (
  setweight(to_tsvector('simple', coalesce(name, '')), 'A') ||
  setweight(to_tsvector('simple', coalesce(slug, '')), 'B')
)
WHERE search_vector IS NULL; -- Only update rows that haven't been processed

-- STEP 4: CREATE THE PERFORMANCE INDEX
-- This GIN index is what makes the full-text search fast.
-- Without it, searches will be very slow on a large table.
CREATE INDEX IF NOT EXISTS "Product_search_vector_idx" ON "Product" USING GIN(search_vector);
```

Type `\q` to exit the psql terminal.

## Useful Docker Commands

```bash
# View real-time logs
docker-compose logs -f

# View logs for a specific service
docker-compose logs -f app
docker-compose logs -f db

# Show existing logs and exit
docker-compose logs

# Restart services
docker-compose restart

# Stop and remove all containers, networks, and volumes
docker-compose down -v

# Rebuild without cache
docker-compose build --no-cache

# Access the app container shell
docker-compose exec app sh

# Access the database container
docker-compose exec db psql -U myuser -d mydb
```

## Troubleshooting

### Database connection errors

- Ensure the `.env` file uses `db` as the host (not `localhost`)
- Check that all services are running: `docker-compose ps`
- View logs: `docker-compose logs db`

### Port already in use

If ports 3000 or 5432 are already in use:

- Stop the conflicting service
- Or modify the ports in `docker-compose.yml`

### Changes not reflecting

- For code changes in dev mode: They should auto-reload
- For Docker/environment changes: Run `docker-compose up --build`

<!-- --- -->

<!-- ## Legacy Setup (Without Docker)

If you need to run the application without Docker, see [LEGACY_SETUP.md](./LEGACY_SETUP.md) for manual PostgreSQL and Node.js installation instructions. -->

---

_Last updated on October 6, 2025 by Ayman._
