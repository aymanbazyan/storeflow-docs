# Setup Guide

This guide details the steps required to set up and run the application using Docker. Docker handles all dependencies including PostgreSQL, Node.js, and the application itself.

## Setup Instructions

### 1. Start the Application

#### Development Mode

:::tip
For faster start time, the `--build` should only be used for the first time running the application.
:::

```bash
# Start services
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up --build -d
```

```bash
# View logs
docker-compose logs -f
```

```bash
# Stop services
docker-compose -f docker-compose.yml -f docker-compose.dev.yml down
```

```bash
# Host Prisma studio
docker-compose exec app npm run prisma:studio
```

#### Production Mode

```bash
# Start services
docker-compose up --build -d
```

```bash
# View logs
docker-compose logs -f
```

```bash
# Stop services
docker-compose down
```

**Note:** The first startup will take longer as it builds the Next.js application and runs database migrations.

### 2. Initialize the Database Schema

The database schema is automatically initialized when you start the application. The Docker entrypoint script runs:

1.  `prisma generate` - Generates the Prisma client
2.  `prisma migrate deploy` - Applies all migrations
3.  Builds and starts the application

### 3. Add Full-Text Search Functionality

:::danger
The application's search feature relies on advanced PostgreSQL functions that **cannot be automatically generated by Prisma**. You must manually execute custom SQL.
:::

**Execute the following commands:**

```bash
# Access the PostgreSQL container
docker-compose exec db psql -U myuser -d mydb
```

Replace `myuser` and `mydb` with the values from your `.env` file.

**Then run this SQL inside the psql terminal:**

```sql
-- STEP 1: DEFINE THE UPDATE FUNCTION
-- This function will be called by the trigger automatically.
-- We use 'setweight' to give matches in 'name' a higher priority ('A')
-- than matches in 'slug' ('B'). This can be used later to rank search results.
CREATE OR REPLACE FUNCTION update_product_search_vector()
RETURNS TRIGGER AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('simple', coalesce(NEW.name, '')), 'A') ||
    setweight(to_tsvector('simple', coalesce(NEW.slug, '')), 'B');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- STEP 2: CREATE THE TRIGGER
-- This trigger ensures the function runs automatically whenever a product is created or updated.
-- We drop the old one first to avoid errors.
DROP TRIGGER IF EXISTS tsvector_update ON "Product";
CREATE TRIGGER tsvector_update
  BEFORE INSERT OR UPDATE ON "Product"
  FOR EACH ROW
  EXECUTE FUNCTION update_product_search_vector();

-- STEP 3: BACKFILL EXISTING DATA (ONE-TIME)
-- This updates all existing products in your table to have a search_vector.
-- It's crucial for making old products searchable.
UPDATE "Product"
SET search_vector = (
  setweight(to_tsvector('simple', coalesce(name, '')), 'A') ||
  setweight(to_tsvector('simple', coalesce(slug, '')), 'B')
)
WHERE search_vector IS NULL; -- Only update rows that haven't been processed

-- STEP 4: CREATE THE PERFORMANCE INDEX
-- This GIN index is what makes the full-text search fast.
-- Without it, searches will be very slow on a large table.
CREATE INDEX IF NOT EXISTS "Product_search_vector_idx" ON "Product" USING GIN(search_vector);
```

Type `\q` to exit the psql terminal.

### 4. Syncing Manual SQL with Prisma Migrations (For feature updates)

After applying the manual SQL for full-text search, you must update Prisma's migration history to prevent errors with future migrations. This process informs Prisma that the manual changes are now part of the official migration history.

**Follow these steps:**

1.  **Create a new, empty migration file:**

    This command generates a new migration folder and a `migration.sql` file but does not apply it to the database.

    ```bash
    docker-compose exec app npx prisma migrate dev --name add-full-text-search --create-only
    ```

2.  **Add the manual SQL to the new migration file:**

    Open the newly created file located at `prisma/migrations/TIMESTAMP_add-full-text-search/migration.sql` and paste the exact same SQL code from **Step 3** into it.

3.  **Mark the migration as applied:**

    This final command tells Prisma to add this migration to its history table _without_ re-running the SQL against your database. This resolves the synchronization issue.

    ```bash
    docker-compose exec app npx prisma migrate resolve --applied TIMESTAMP_add-full-text-search
    ```

    _Replace `TIMESTAMP_add-full-text-search` with the actual folder name generated in the first step._

After completing these steps, you can run `prisma migrate dev` as usual for any future schema changes.

---

## Useful Docker Commands

```sql
# View real-time logs
docker-compose logs -f

# View logs for a specific service
docker-compose logs -f app
docker-compose logs -f db

# Show existing logs and exit
docker-compose logs

# Restart services
docker-compose restart

# Stop and remove all containers, networks, and volumes
docker-compose down -v

# Rebuild without cache
docker-compose build --no-cache

# Access the app container shell
docker-compose exec app sh

# Access the database container
docker-compose exec db psql -U myuser -d mydb
```

## Troubleshooting

### Database connection errors

- Ensure the `.env` file uses `db` as the host (not `localhost`)
- Check that all services are running: `docker-compose ps`
- View logs: `docker-compose logs db`

### Port already in use

If ports 3000 or 5432 are already in use:

- Stop the conflicting service
- Or modify the ports in `docker-compose.yml`

### Changes not reflecting

- For code changes in dev mode: They should auto-reload
- For Docker/environment changes: Run `docker-compose up --build`

---

_Last updated on December 20, 2025 by Ayman._
